
import numpy as np


def load_from_github(url):
    from urllib.request import urlopen
    from os import remove
    
    obj = urlopen(url)
    assert obj.getcode()==200,"unable to open"

    s = str(obj.read(), encoding="utf-8")
    NAME = "_temp.py"
    with open(NAME, mode='wt', encoding='utf-8') as fh: fh.write(s)
    module = __import__(NAME[:-3])
    remove(NAME)
    return module


url = r"https://raw.githubusercontent.com/leztien/synthetic_datasets/master/make_data_for_ANN.py"
module = load_from_github(url)
X,y = module.make_data_for_ANN(m=1000, n=2, K=5, L=3, u=16, gmm=True, balanced_classes=True, seed=True)



from sklearn.base import BaseEstimator, ClassifierMixin

class MLP(BaseEstimator, ClassifierMixin):
    def __init__(self, layers, activation, validation, verbose):
        pass
    
    def fit(self, X,y):
        pass
    
    def probabilities(self, X):
        pass
    
    def predict(self, X):
        pass
    
    #register activation functions (make each function also return its initializer)
    @staticmethod
    def linear(input=None, derivative=False, initializer=False):
        pass



md = MLP(1,2,3,4)

layers = (32,16,8)
activation = None



m,n = X.shape
classes = sorted(set(y))
K = len(classes)


shapes = (n,) + layers + (K,)  #temporary
shapes = [(m,n) for m,n in zip(shapes[1:],shapes[:-1])]



########
functions_register_list = []

def decorator_function(func):
    global functions_register_list
    functions_register_list.append(func.__name__)
    free_variable = 0
    def closure_function(*args, **kwargs):
        nonlocal free_variable
        free_variable += 1
        result = func(*args, **kwargs)
        return (free_variable, result)
    return closure_function

@decorator_function
def fn1(arg1, arg2=20, *, kw1, kw2):
    return (arg1, arg2, kw1, kw2)

print(functions_register_list)      #['fn1',]
output = fn1(10, kw1=100, kw2=200)  #(1, (10, 20, 100, 200))
output = fn1(10, kw1=100, kw2=200)  #(2, (10, 20, 100, 200))











