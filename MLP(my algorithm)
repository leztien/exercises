
import numpy as np


def load_from_github(url):
    from urllib.request import urlopen
    from os import remove
    
    obj = urlopen(url)
    assert obj.getcode()==200,"unable to open"

    s = str(obj.read(), encoding="utf-8")
    NAME = "_temp.py"
    with open(NAME, mode='wt', encoding='utf-8') as fh: fh.write(s)
    module = __import__(NAME[:-3])
    remove(NAME)
    return module


url = r"https://raw.githubusercontent.com/leztien/synthetic_datasets/master/make_data_for_ANN.py"
module = load_from_github(url)
X,y = module.make_data_for_ANN(m=1000, n=2, K=5, L=3, u=16, gmm=True, balanced_classes=True, seed=True)



from sklearn.base import BaseEstimator, ClassifierMixin

class MLP(BaseEstimator, ClassifierMixin):
    def __init__(self, layers, activation, validation, verbose):
        self.activation = get_activation_function(activation)
        
    def fit(self, X,y):
        pass
    
    def probabilities(self, X):
        pass
    
    def predict(self, X):
        self.linear
        pass
    



#===================================================================

def get_activation_function(name):
    d = dict()
    
    def register(func):
        nonlocal d
        d.setdefault(func.__name__.lower().strip(), func)
        return func
    
    #paste your activation functions here:
    @register
    def linear(input, derivative=False, initializer=False):
        return input
    
    @register
    def leakyrelu(input, derivative=False, initializer=False):
        return input
    
    @register
    def sigmoid(input, derivative=False, initializer=False):
        return input
    
    #provide for double names (of activation functions)
    t = (
    ['logistic','sigmoid'],
    ['leaky','leakyrelu','leaky-relu','leaky_relu'],
    ['tanh','tangent hyporbolic']
    )
    
    for i in range(len(t)):
        l = [s for s in d.keys() if s in t[i]]
        if l:
            t[i].remove(l[0])
            [d.__setitem__(k, d[l[0]]) for k in t[i]]
    
    #get the appropriate activation function from the dictionary
    if name is None:
        return d["sigmoid"]
    else:
        try: return d[str(name).lower().strip()]
        except KeyError:
            msg = "No such activation function: " + str(name)
            raise ValueError(msg)



####################################################################################







md = MLP(1,None,3,4)



layers = (32,16,8)
activation = None



m,n = X.shape
classes = sorted(set(y))
K = len(classes)


shapes = (n,) + layers + (K,)  #temporary
shapes = [(m,n) for m,n in zip(shapes[1:],shapes[:-1])]




