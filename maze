

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle, Circle

s =\
"""
++++++++++++++++++++++
+   +   ++ ++        +
  + + +     +++ +++ ++
+ + +  ++  ++++ +++ ++
+ + + + + ++    +++  +
+          ++  ++  + +
+++++ + +      ++  + +
+++++ +++  + +  ++   +
+          + +  + +  +
+++++ +  + + +     + +
++++++++++++++++++++++
"""


def str_to_mx(s:"str representation of a maze") -> np.ndarray:
    d = str.maketrans({'+':'1', ' ':'0'})
    s = s.strip().translate(d)
    mx = [[int(e) for e in s] for s in s.strip().split('\n')]
    return np.array(mx, dtype='uint8')


class Maze:
    def __init__(self, layout, moves):
        self._layout = layout
        self._starting_position = moves[0]
        self._moves = moves[1:]
        self._n_updates_per_move = 4
        self._step = 1/self._n_updates_per_move
        self.frames = len(self._moves) * self._n_updates_per_move
        self._skip_first_update = True  #bug?

    def update(self, frame):  # 1 move = 4 updates
        #must skip the fursz zero update (matplotlib bug?)
        if frame==0 and self._skip_first_update:
            self._skip_first_update = False
            return


        ix = frame // self._n_updates_per_move
        direction = abs(self._moves[ix])
        drop_breadcrum = True if (self._moves[ix] < 0 and frame%self._n_updates_per_move==0) else False


        circle = self.circle
        x,y = circle.get_center()

        #leave breadcrum
        if drop_breadcrum:
            print("leaving breadcrum @", frame, ix, direction)
            breadcrum = Circle(xy=(x, y), radius=0.1, color='yellow', zorder=-1)
            self.sp.add_patch(breadcrum)



        #move the turtle further
        if direction == 1: y -= self._step
        elif direction == 2: x += self._step
        elif direction == 3: y += self._step
        elif direction == 4: x -= self._step
        else: pass

        #check if bumped into a wall
        r,c = [int(y-0.5), int(x-0.5)]
        bumped = (self._layout[r,c]==1)and(frame%self._n_updates_per_move==0)
        if bumped:
            print("bumped into the wall @", r,c)


        circle.set_center([x,y])
        print(frame, ix, direction)



    def go(self):
        from matplotlib.animation import FuncAnimation
        self.draw_maze()
        self.place_turtle()
        anim = FuncAnimation(self.fig, self.update, frames=self.frames, interval=67, repeat=False)
        plt.show()


    def draw_maze(self):
        mx = self._layout
        m,n = mx.shape
        fig = plt.figure()
        sp = fig.add_subplot(111)

        sp.set(xlim=(0,n), ylim=(m,0))
        sp.set(xticks=[], yticks=[])
        sp.set_facecolor("orange")

        #get indeces and draw bricks
        nx_row, nx_col = np.indices(mx.shape)
        MASK = mx==1
        nx = tuple(zip(nx_col[MASK], nx_row[MASK]))
        [sp.add_patch(Rectangle(xy=xy, width=1, height=1, color='brown', ec='k')) for xy in nx]
        self.fig = fig
        self.sp = sp
        return fig,sp

    def place_turtle(self):
        from matplotlib.patches import Circle
        y,x = self._starting_position
        circle = Circle(xy=(x+.5, y+.5), radius=0.3, color='darkblue')
        self.sp.add_patch(circle)
        self.circle = circle
        return circle

    def move(self, direction):
        pass



def solve_maze(layout, moves=None):
    #choose starting position
    start = tuple(moves[0])
    assert layout[start] == 0, "bad starting position"

    maze = Maze(layout, moves)
    maze.go()
    return moves










###################################

def make_random_walk(layout, start=None, n=100):
    from random import randint
    position = np.array(start or (5, 9), dtype='uint8')  # np.array((5,9), dtype='uint8')
    d = {1: (-1, 0), 2: (0, 1), 3: (1, 0), 4: (0, -1)}
    moves = list()

    while (len(moves) < n):
        direction = randint(min(d.keys()), max(d.keys()))
        new_position = position + d[direction]
        try:
            v = layout[tuple(new_position)]
            assert v == 0, "bumped into the wall!"
            assert (new_position == new_position.__abs__()).all(), "negative index!"

        except (IndexError, AssertionError):
            continue
        else:
            position = new_position
            moves.append(direction)
    moves = list((tuple(start),)) + [-n for n in moves]
    return (moves)



layout = str_to_mx(s)
moves = make_random_walk(n=100, layout=layout, start=(5, 9))
#solve_maze(layout, moves=moves)





def make_straight_walk(layout, start=None, n=100):
    from collections import deque
    position = np.array(start or (5, 9), dtype='uint8')  # np.array((5,9), dtype='uint8')
    d = {1: (-1, 0), 2: (0, 1), 3: (1, 0), 4: (0, -1)}
    q = deque((1,2,3,4), maxlen=4)
    moves = list()
    layout = layout.copy()

    #while (len(moves) < n):
    for _ in range(100):
        direction = q[0]
        new_position = position + d[direction]
        try:
            v = layout[tuple(new_position)]
            assert v != 1, "bumped into the wall!"
            assert (new_position == new_position.__abs__()).all(), "negative index!"

        except (IndexError, AssertionError):
            q.append(q[0])
        else:
            #check the new_position
            if layout[tuple(new_position)] == 2:
                q.append(q[0])
                continue
                pass

            #accept the new position as good and make that move
            layout[tuple(position)] = 2
            position = new_position
            moves.append(direction)

    moves = list((tuple(start),)) + [-n for n in moves]
    return (moves)



moves = make_straight_walk(layout, start=(5,9), n=100)
#print(moves)

solve_maze(layout, moves=moves)




